接口文档访问`http://127.0.0.1:8000/docs/`,但是报错`AttributeError: 'AutoSchema' object has no attribute 'get_link'`

# 前后端分离
## 1. 交互形式
[![Snipaste-2023-07-24-09-23-09.png](https://i.postimg.cc/gjXMP3bp/Snipaste-2023-07-24-09-23-09.png)](https://postimg.cc/4HGv6732)

### restful api与传统api区别

> restful api与传统api区别有：
> 
> 1、功能不同；
> 
> 2、methods多样性不同；
> 
> 3、接口不同；
> 
> 4、结构不同；
> 
> 5、设计不同；
> 
> 6、协议不同；
> 
> 7、支持不同；
> 
> 8、可扩展性不同。
> 
> 其中，功能不同指的是restful API是当作资源的唯一标识符，而传统API是为了实现某种功能。

### 1、功能不同
**restful api**：restful API是当作资源的唯一标识符。

**传统api**：传统API是为了实现某种功能。

### 2、methods多样性不同
**restful api**：Restful API methods:

> post 创建数据
> 
> get 获取数据
> 
> put/patch是更新数据
> 
> delete是删除数据

**传统api**：传统API只有get获取数据，其他都是POST解决。

### 3、接口不同
**restful api**：restful API遵循统一接口的原则，禁止在API中使用自接口或多个接口。理想情况下，超媒体连接应用于分发单个接口。它还应确保类似的数据片段（例如，用户名或电子邮件地址）仅属于一个统一资源标识符 （URI）。因此，无论初始请求如何，对相同资源的所有 API 请求都应看起来相同。简化了API接口的操作性和统一性：

> api/file 只需要这一个接口
> 
> GET 方式请求 api/file – 获取文件信息，下载文件
> 
> POST 方式请求 api/file – 上传创建文件
> 
> DELETE 方式请求 api/file – 删除某个文件

**传统api**：传统接口：

> api/getfile.php – 获取文件信息，下载文件
> 
> api/uploadfile.php – 上传创建文件
> 
> api/deletefile.php – 删除文件

### 4、结构不同
**restful api**：restful api严格地在客户端和服务器的Web概念上运行。客户端和服务器彼此分离，提供了更大的灵活性。

**传统api**：在结构上，大多数API遵循应用程序 – 应用程序格式。

### 5、设计不同
**restful api**：restful api通过系统进行通信，使其成为一个复杂的架构。

**传统api**：API 是轻量级体系结构，专为限制在智能手机等设备上的小工具而设计。

### 6、协议不同
**restful api**：restful api是一种架构风格，用于构建通过HTTP协议进行交互的Web服务。尽管restful api是由计算机科学家Roy Fielding在2000年制定的，但它仍然是公共API的黄金标准。

**传统api**：API 的主要目标是标准化 Web 服务之间的数据交换。根据 API 的类型，协议的选择会发生变化。

### 7、支持不同
**restful api**：即使用户不知道函数名称和参数的特定顺序，也会执行相比之下，即使用户不知道函数名称和参数的特定顺序，也会执行 restful API。

**传统api**：大多数API都很容易实现，因为它们不会面临无状态。

### 8、可扩展性不同
**restful api**：REST API具有分层结构，使得REST API模块化，并且更灵活地实现可扩展性。

**传统api**：可扩展性是通用API的一个问题。

API是一个更大的保护伞，restful API是移动和云应用程序中普遍存在的独特类型的API。没有一个API是没有缺点的，但新的开发人员发现restful API很困难，因为它无法在会话中保持状态。随着现代 API 成为符合特定标准和特定受众的产品，企业已迅速改进其用户界面。

## 2. 代码组织方式
[![Snipaste-2023-07-24-09-39-54.png](https://i.postimg.cc/44cf5Mj8/Snipaste-2023-07-24-09-39-54.png)](https://postimg.cc/0r815tkm)

第一种 django 有个 templates 文件夹 是放 前端代码的

[![Snipaste-2023-07-24-09-43-56.png](https://i.postimg.cc/W3XMfzDv/Snipaste-2023-07-24-09-43-56.png)](https://postimg.cc/hzQzXSby)

**前后端分离最明显的优势是解耦**

## 3. 开发模式
### 前后端不分离开发模式
[![20230724095343.png](https://i.postimg.cc/BQyRVQDH/20230724095343.png)](https://postimg.cc/w7XWtzwj)

### 前后端分离模式
[![20230724095518.png](https://i.postimg.cc/3x5nGymS/20230724095518.png)](https://postimg.cc/VdgqQk7n)


## 4. 数据接口规范流程
[![20230724095556.png](https://i.postimg.cc/Sj07c522/20230724095556.png)](https://postimg.cc/ZvcdSwL4)

## 优点
### 1.可多端化
### 2.提升开发效率
### 3.增强代码可维护性

# Github API v3使用
[Github API v3](https://docs.github.com/zh/rest?apiVersion=2022-11-28) 表示 REST API

[Github API v4](https://docs.github.com/zh/graphql) 表示 GraphQL 接口

这里有三种`GitHub CLI`、`curl`、`javascript`
这里采用`curl`方式导入到`apifox`

[![Snipaste-2023-07-27-09-18-00.png](https://i.postimg.cc/65WBSqfM/Snipaste-2023-07-27-09-18-00.png)](https://postimg.cc/K4WX3ZVT)

# 配置权限认证 `Authentication`
## 认证方法一：Basic authentication
这种最简单，如果是用curl的话，就：
```sh
curl -u "用户名:密码" https://api.github.com
```
如果是用Insomnia等api调试工具的话，直接在Auth选项栏里选Basic Auth，然后填上用户名密码即可。

## 认证方法二：OAuth2 token
### 关于token
> 这种token方式，说实话如果不是操作过API或深度了解REST的话，是很难理解的东西。
> 
> 说白了就是第二个密码，你既不用到处泄露自己的用户名密码，又可以专门给这个"第二密码"设置不同需要的权限，如有的只可读有的还可以写等。而且这个“第二密码”是既包括用户名又包括密码功能的，全站只此一个绝对不会和别人重复。初次之外，你还可以设置很多个token，也就是第三、第四、第五...密码。很方便。


### 设置token方法
就位于github个人账号设置->开发者设置->个人token里。创建一个新token时，可以选择具体的权限，创建成功时一定要复制到本地哪里保存，只会让你看见一次，如果忘记的话就需要重新生成（其实丢了也不算麻烦）。
https://github.com/settings/personal-access-tokens/new

只需要输入`Token name`,然后点击`generate token`即可
[![Snipaste-2023-07-27-09-45-04.png](https://i.postimg.cc/c1Pd1WwS/Snipaste-2023-07-27-09-45-04.png)](https://postimg.cc/z3wsp9xt)

#### 用token通过权限认证
有两种传送方法，哪种都可以：

1.作为url中的参数明文传输：
```sh
curl https://api.github.com/?access_token=OAUTH-TOKEN
```
2. 作为header中的参数传输：
```sh
curl -H "Authorization: token OAUTH-TOKEN" https://api.github.com
```
如果不是用curl而是Insomnia测试的话，和上面basic auth是大同小异的，很容易操作就不复述了。
到此为止，权限认证就算搞清了，而且也实际验证过有效了。强烈建议用insomnia工具操作，有GUI界面方便理解，成功后再转为curl或python等程序语言。

## 认证方法三：OAuth2 key/secret
这个是除了Personal Access Token之外的另一种好用的方法，即创建自己的OAuth app，然后得到一对`client_id`和`client_secret`。如下：

[![Snipaste-2023-07-27-09-56-22.png](https://i.postimg.cc/5tzR3cjw/Snipaste-2023-07-27-09-56-22.png)](https://postimg.cc/Z9THbM8R)

[![Snipaste-2023-07-27-09-59-27.png](https://i.postimg.cc/4dTF28hj/Snipaste-2023-07-27-09-59-27.png)](https://postimg.cc/rdQJKNj9)


![](https://segmentfault.com/img/remote/1460000015144133)

![](https://segmentfault.com/img/remote/1460000015144134)


得到这两个值之后，直接在访问任何api的url连接后面显性加上这两个参数即可完成认证，如：
https://api.github.com/users/yourusername?client_id=YOUR-CLIENT-ID&client_secret=YOUR-CLIENT-SECRET
但是：

> 目前这种认证方式**不支持**查询以外的操作，也就是只能GET获取某些api信息，不能执行request里的任何PUT/PATCH/DELETE操作。




## 使用`curl`方式导入到`apifox`
首先新建一个项目，然后选择导入

[![Snipaste-2023-07-27-09-20-59.png](https://i.postimg.cc/WzKSMhNs/Snipaste-2023-07-27-09-20-59.png)](https://postimg.cc/2LQ4YjLt)


```
curl --request GET \
--url "https://api.github.com/repos/octocat/Spoon-Knife/issues" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer YOUR-TOKEN"
```

**注意：在大多数情况下，您可以使用 `Authorization: Bearer` 或 `Authorization: token` 传递令牌。但是，如果要传递 JSON Web 令牌 （JWT），则必须使用 `Authorization: Bearer` .**

