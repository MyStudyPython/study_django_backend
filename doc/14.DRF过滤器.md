DRF提供了过滤功能，来实现简单高效的过滤。

views.py如下：
```python
class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    '''商品列表页'''

    # queryset = Goods.objects.all()
    serializer_class = GoodsSerializer
    pagination_class = GoodsPagination

    def get_queryset(self):
        queryset = Goods.objects.all()
        price_min = self.request.query_params.get('price_min', default=0)
        if price_min:
            queryset = queryset.filter(shop_price__gt=int(price_min))
        return queryset

```

显示：

![](https://img-blog.csdnimg.cn/20200725155149781.gif)


显然，在传入`price_min`参数后，显示到前端的数据量也会发生变化。

但是这显得很麻烦，可以用更简单的方式实现，即使用django-filter实现，包括**DjangoFilterBackend（与后台管理系统表现相同）、SearchFilter、OrderingFilter**等，即字段**过滤、搜索、排序**3种方式。

# 过滤的使用
通过django-filters的**DjangoFilterBackend**类实现字段过滤。
先实现精确过滤，views.py如下：

```python
class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    '''商品列表页'''

    queryset = Goods.objects.all()
    serializer_class = GoodsSerializer
    pagination_class = GoodsPagination
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['name', 'market_price']

```

settings.py中进行配置：
```python
# DRF配置
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
}

```

此时，可以根据字段进行过滤，但是只能精确比配，对于字符串型字段不能模糊匹配，对于数值型字段也不能匹配区间，因此需要自定义`filters`，新建`filters.py`如下：

```python
import django_filters

from .models import Goods

class GoodsFilter(django_filters.rest_framework.FilterSet):
    '''商品过滤类'''
    name = django_filters.CharFilter(field_name="name", lookup_expr='contains')
    min_price = django_filters.NumberFilter(field_name="market_price", lookup_expr='gte')
    max_price = django_filters.NumberFilter(field_name="market_price", lookup_expr='lte')

    class Meta:
        model = Goods
        fields = ['name', 'min_price', 'max_price']

```

views.py修改如下：